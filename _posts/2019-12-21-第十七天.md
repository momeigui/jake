---
title: 第十七天-学美术的英语小白如何三十天学会前端三大利器
key: 20191221
tags: 学习 前端 自学编程
author: AmorSpem
article_header:
  type: cover
  image:
    src: 'https://pic.superbed.cn/item/5e04ce6976085c328974391a.jpg'

---

> 话说北京吉野家有15块一位的早餐自助,好想去吃,但好像不是每个店都有~~
>
> 墨迹了半天才把js对象给看完,搞了一个什么鬼构造函数
>
> 今天四次

![img](https://pic3.superbed.cn/item/5e04ceb776085c3289744c55.jpg)

**今天学了什么**

### **js对象**

- 在 JavaScript 中，被称为 this 的事物，指的是拥有该 JavaScript 代码的对象。
- this 的值，在函数中使用时，是“拥有”该函数的对象。
- 请注意 this 并非变量。它是关键词。您无法改变 this 的值。
- String 对象的 toUpperCase() 方法，把文本转换为大写
- Getter 和 Setter 允许您定义对象访问器（被计算的属性）。
- ...这个鬼东西我看了半天...虽然说是一个以函数方式访问,一个以属性形式访问..但是没区别啊...

- 为什么使用 Getter 和 Setter？

- 它提供了更简洁的语法
- B 它允许属性和方法的语法相同
- 它可以确保更好的数据质量
- 有利于后台工作...
- Object.defineProperty() 方法也可用于添加 Getter 和 Setter

```javascript
var obj = {
    counter : 0,
    get reset() {
      this.counter = 0;
    },
    get increment() {
      this.counter++;
    },
    get decrement() {
      this.counter--;
    },
    set add(value) {
      this.counter += value;
    },
    set subtract(value) {
      this.counter -= value;
    }
  };

  // 操作计数器：
  obj.reset;
  obj.add = 5;
  obj.subtract = 1;
  obj.increment;
  obj.decrement;
  Object.defineProperty()
```

### **构造函数 Person() = = 我擦.看不懂啊...**

- 我好像有点懂了,但又不是很明白....
- 建一种“对象类型”的方法，是使用对象构造器函数。
- 这里又出现this关键字了...
- 在 JavaScript 中，被称为 this 的事物是代码的“拥有者”。
- this 的值，在对象中使用时，就是对象本身。
- 在构造器函数中，this 是没有值的。它是新对象的替代物。当一个新对象被创建时，this 的值会成为这个新对象。
- 请注意 this 并不是变量。它是关键词。您无法改变 this 的值。
- 添加新属性和新方法的方式都和以前一样
- 构造器无法添加新的属性 无法为对象构造器添加新方法。
- 但是可以通过构造函数内部来添加方法
- 构造器函数可以定义方法
- 服了....前面教程还说不能添加...转眼间来个了函数....prototype属性允许为对象构造器添加新属性!!!也可以添加新方法....

### **JavaScript ES5对象方法添加了一堆**

```javascript

// 添加或更改对象属性
Object.defineProperty(object, property, descriptor)
// 添加或更改多个对象属性
Object.defineProperties(object, descriptors)
// 访问属性
Object.getOwnPropertyDescriptor(object, property)
// 以数组返回所有属性
Object.getOwnPropertyNames(object)
// 以数组返回所有可枚举的属性
Object.keys(object)
// 访问原型
Object.getPrototypeOf(object)
// 阻止向对象添加属性
Object.preventExtensions(object)
// 如果可将属性添加到对象，则返回 true
Object.isExtensible(object)
// 防止更改对象属性（而不是值）
Object.seal(object)
// 如果对象被密封，则返回 true
Object.isSealed(object)
// 防止对对象进行任何更改
Object.freeze(object)
// 如果对象被冻结，则返回 true
Object.isFrozen(object)
```